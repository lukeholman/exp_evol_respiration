---
title: "Statistical analysis"
output: 
  workflowr::wflow_html:
    code_folding: hide 
editor_options:
  chunk_output_type: console
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

## Load R packages
```{r}
library(tidyverse)
library(gridExtra)
library(grid)
library(brms)
library(RColorBrewer)
library(glue)
library(kableExtra)
library(tidybayes)
library(bayestestR)
library(MuMIn)
library(glue)
library(ggridges)
library(future)
library(future.apply)
library(GGally)

library(knitrhooks) # install with devtools::install_github("nathaneastwood/knitrhooks")

output_max_height() # a knitrhook option
options(stringsAsFactors = FALSE)

# Define function for the inverse logit
inv_logit <- function(x) 1 / (1 + exp(-x))
```

## Load respirometry data
```{r}
respiration <- read_csv("data/2.metabolic_rates.csv") %>%
  rename(SELECTION = `?SELECTION`)
```

## Draw the flow diagram

```{r}
DiagrammeR::grViz('digraph {

graph [layout = dot, rankdir = LR]

# define the global styles of the nodes. We can override these in box if we wish
node [shape = rectangle, style = filled, fillcolor = Linen]

"Metabolic\nrate" [shape = oval, fillcolor = Beige]
"Metabolic\nsubstrate" [shape = oval, fillcolor = Beige]
"Other factors\n(e.g. physiology)" [shape = oval, fillcolor = Beige]

# edge definitions with the node IDs
"Mating system\ntreatment (M vs P)" -> {"Other factors\n(e.g. physiology)", "Body mass" , "Activity"} -> {"Metabolic\nrate", "Metabolic\nsubstrate"} 

{"Metabolic\nrate"} -> {"O\u2082 consumption", "CO\u2082 production"}
{"O\u2082 consumption", "CO\u2082 production"} -> "Respiratory\nquotient (RQ)"
{"Metabolic\nsubstrate"} -> "Respiratory\nquotient (RQ)"
}')
```
<br></br>
**Figure 1:** Directed acyclic graph (DAG) showing the key causal relationships that we hypothesised a priori between the measured variables (squares) and latent variables (ovals). This DAG motivated the Bayesian structural equation model discussed in the Methods and Results, which attempts to decompose the effects of treatment on respiration (measured via O2 and CO2 flux, and their ratio, RQ) into paths that travel via body mass, activity, or other unmeasured factors such as physiology.


## Inspecting the raw data

Create a "pairs plot" of the raw data. 

```{r}

modified_densityDiag <- function(data, mapping, ...) {
  ggally_densityDiag(data, mapping, ...) + scale_fill_brewer(type = "qual", palette = "Set1", direction = -1) + 
  scale_x_continuous(guide = guide_axis(check.overlap = TRUE))
}

modified_points <- function(data, mapping, ...) {
  ggally_points(data, mapping, ...) + scale_colour_brewer(type = "qual", palette = "Set1", direction = -1) + 
  scale_x_continuous(guide = guide_axis(check.overlap = TRUE))
}

modified_facetdensity <- function(data, mapping, ...) {
  ggally_facetdensity(data, mapping, ...) + scale_colour_brewer(type = "qual", palette = "Set1", direction = -1)
}

modified_box_no_facet <- function(data, mapping, ...) {
  ggally_box_no_facet(data, mapping, ...) + scale_fill_brewer(type = "qual", palette = "Set1", direction = -1)
}

pairs_plot <- respiration %>% 
  select(SEX, SELECTION, CYCLE, VO2, VCO2, RQ, ACTIVITY, BODY_WEIGHT) %>%
  mutate(VO2 = VO2 * 1000, 
         VCO2 = VCO2 * 1000, 
         BODY_WEIGHT = BODY_WEIGHT * 1000, 
         ACTIVITY = ACTIVITY * 100) %>%
  mutate(SEX = factor(ifelse(SEX == "M", "Male", "Female"), c("Male", "Female"))) %>%
  rename(Sex = SEX, Treatment = SELECTION, Cycle = CYCLE, 
         Activity = ACTIVITY, `Body mass` = BODY_WEIGHT) %>%
  ggpairs(aes(colour = Treatment),
          diag = list(continuous = wrap(modified_densityDiag, alpha = 0.7),
                      discrete = wrap("blank")),
          lower = list(continuous = wrap(modified_points, alpha = 0.7, size = 0.5), 
                       discrete = wrap("blank"),
                       combo = wrap(modified_box_no_facet, alpha = 0.7)),
          upper = list(continuous = wrap(modified_points, alpha = 0.7, size = 0.5),
                       discrete = wrap("blank"),
                       combo = wrap(modified_facetdensity, alpha = 0.7, size = 0.5))) 

pairs_plot %>% ggsave(filename = "output/pairs_plot.pdf", height = 10, width = 10)
pairs_plot
```

**Figure 2:** Boxplots, scatterplots, and density plots illustrating the variance and covariance among the explanatory variables (Treatment, Sex, and Cycle) and the five response variables. The data are coloured by treatment (red for polyandry, blue for monogamy). The plot shows the raw data in their original units, namely the number of mm of O2 consumed or CO2 produced, the % time spent active, and the mass of the fly in milligrams (RQ is a ratio and thus has no units). Note that RQ has as expected range of 0.7-1.0 because of the chemistry of respiration, but values outside this range often occur due to measurement error for O2 and/or CO2. 

## Fit the first `brms` models, ignoring the moderator variables

### Scale the input data

Here, we scale and centre the body mass and activity (across all samples), and multiply VO2 and VCO2 by 1000 so that their units (and resulting regression coefficients) are close to those assumed by the `brms` default priors. 

We did not scale and centre VO2 and VCO2, because we will soon relate them to each other via the respiratory quotient, RQ, so it makes sense to leave them in their original units rather than converting their units to standard deviations. 

Note that body mass and activity are not actually used until the following section (i.e. _Fit the `brms` structural equation model (SEM)_).

```{r}
scaled_data <- respiration %>%
  mutate(VO2 = VO2 * 1000, 
         VCO2 = VCO2 * 1000,
         BODY_WEIGHT = as.numeric(scale(BODY_WEIGHT)),
         ACTIVITY = as.numeric(scale(ACTIVITY))) %>% 
  rename(BODYMASS = BODY_WEIGHT)
```

### Write out the full model's formulae

Here, I write out all the formulae for the "full model", as well as their equivalents for all the simpler models nested within the full model. All of these models contain more than one formula each (i.e. they are multivariate models): one formula for oxygen consumption (VO2) and one for CO2 production (VCO2), as well as a formula for the parameter RQ (the respiratory quotient, i.e. VCO2 / VO2). I assume that VO2 and RQ are both affected by the  predictor variables that resukt from the experimental design, namely SELECTION (i.e. M vs P treatment), SEX (Male or Female), CYCLE (I, II, or III: this refers to the first, second, and third measurement of O2 and CO2 for each triad of flies), LINE (a random intercept term with 8 levels, one for each of the four independent replicates of the M an P treatmens), and SAMPLE (which identifies the three replicate measures of each triad of flies across the three cycles). The formulae for VO2 and VCO2 are as follows:

#### VO2

Formula: `VO2 ~ SELECTION * SEX * CYCLE + (1 | LINE) + (1 | SAMPLE)`  
         
This formula allows for effects on VO2 of sex, selection and cycle (and all 2- and 3-way interactions), and models the variation in VO2 within and between each triad of flies and each replicate selection line (preventing pseudo-replication by properly accounting for our experimental design). 

#### VCO2 (as determined by the parameter RQ) 

Formulae (2-part model, see `vignette("brms_nonlinear")`): 

`VCO2 ~ VO2 * (0.7 + 0.3 * inv_logit(RQ))`

`RQ ~ SELECTION * SEX * CYCLE + (1 | LINE) + (1 | SAMPLE)`

VCO2 is assumed to depend on the value of VO2 from the same measurement, multiplied by RQ, a parameter that is constrained to vary between 0.7 and 1 (based on our prior knowledge of the chemistry of respiration) through the use of the inverse logit function. In turn, RQ is assumed to depend on the same set of predictors as for VO2. 

#### Priors

To apply some mild regularisation and assist model convergence, we set a prior on all the fixed effect parameters of `normal(0, 3)`.

#### Family

All response variables are assumed to follow a normal (Gaussian) distribution.

### Finding all the sub-models for model selection

Now that we have written out the full model, we can find all its component sub-models. This is complicated by the fact that it is a multivariate model, and so we need to find the sub-models for both VO2 and RQ, and then find all possible combinations of these. 

```{r}
# For convenience, we borrow the function `dredge()` from the MuMIn package, 
# and use it find all submodels
all_sub_models <- paste(get.models(with(options(na.action = na.fail), 
                      dredge(lm(VO2 ~ SELECTION * SEX * CYCLE, data = scaled_data))), subset = TRUE) %>%
  map_chr(~ as.character(.x$call)[2]) %>% 
    unname() %>% 
    str_remove_all(" [+] 1") %>% 
    str_remove_all("VO2 ~ "), 
  "+ (1 | LINE) + (1 | SAMPLE)") 

# Find all combinations of sub-model formulas for VO2 and RQ
combos <- expand.grid(vo2 = all_sub_models, 
                      rq = all_sub_models, stringsAsFactors = FALSE)

# Write out the complete multi-part formulas for all 361 to be compared
write_formula <- function(vo2, rq){
glue("
bf(VO2 ~ {vo2}) + bf(VCO2 ~ VO2 * (0.7 + 0.3 * inv_logit(RQ)), RQ ~ {rq}, nl = TRUE) + set_rescor(FALSE)") %>% 
    as.character()
}

all_formulas <- map2(combos[,1], 
                     combos[,2], 
                     write_formula)

print("Inspect the first few formulas:")
head(unlist(all_formulas))
```

### Run all the `brms` models and save them to disk

Here, we run all 361 of the models whose formulae are given in the vector `all_formulas`, and save the results of each model to an external hard drive (this uses about 55GB). Note that the prior for each model is the same, except that one does not need to specify a prior on the fixed effects in models that do not contain any fixed effects, which is why the `if()` statements are needed.  

```{r eval = FALSE}
# Function to run a model using formula number "i" in "formula_list" on dataframe "my_data"
run_model <- function(i, formula_list, my_data){
  
  save_location <- "/Volumes/LACIE_SHARE/brms_respiration"
  num <- str_pad(i, 3, pad = "0")
  file_name <- glue("{save_location}/model_{num}.rds")
  if(file.exists(file_name)) return(NULL)
  
  focal_formula <- eval(parse(text = formula_list[[i]]))
  
  if(!str_detect(focal_formula, "VO2 ~ 1") & !str_detect(focal_formula, "RQ ~ 1")){
    model <- brm(focal_formula, 
                 data = my_data, 
                 iter = 10000, chains = 4, cores = 1,
                 prior = c(prior(normal(0, 3), class = "b", resp = "VO2"),
                           prior(normal(0, 3), class = "b", resp = "VCO2", nlpar = "RQ")),
                 control = list(max_treedepth = 20, adapt_delta = 0.99),
                 save_all_pars = TRUE)
  } 
  if(!str_detect(focal_formula, "VO2 ~ 1") & str_detect(focal_formula, "RQ ~ 1")){
    model <- brm(focal_formula, 
                 data = my_data, 
                 iter = 10000, chains = 4, cores = 1,
                 prior = prior(normal(0, 3), class = "b", resp = "VO2"),
                 control = list(max_treedepth = 20, adapt_delta = 0.99),
                 save_all_pars = TRUE)
  }
  if(str_detect(focal_formula, "VO2 ~ 1") & !str_detect(focal_formula, "RQ ~ 1")){
    model <- brm(focal_formula, 
                 data = my_data, 
                 iter = 10000, chains = 4, cores = 1,
                 prior = prior(normal(0, 3), class = "b", resp = "VCO2", nlpar = "RQ"),
                 control = list(max_treedepth = 20, adapt_delta = 0.99),
                 save_all_pars = TRUE)
  }
  if(str_detect(focal_formula, "VO2 ~ 1") & str_detect(focal_formula, "RQ ~ 1")){
    model <- brm(focal_formula, 
                 data = my_data, 
                 iter = 10000, chains = 4, cores = 1,
                 control = list(max_treedepth = 20, adapt_delta = 0.99),
                 save_all_pars = TRUE)
  }
  
  saveRDS(model, file = file_name)
  rm(model) # Force clean up to help R not run out of memory
  gc()
  return(NULL)
}

# Run all the models in parallel over 4 cores - this worked fine on a 2015 iMac with 32GB RAM
options(mc.cores=4)
plan(multiprocess)

future_lapply(1:length(all_formulas), 
              run_model, 
              formula_list = all_formulas, 
              my_data = scaled_data)
```

### Compare all the fitted `brms` models using leave-one-out cross validation (LOO)

It is not possible to load all the models without running out of memory, so I here use a simple algorithm to select the top 10 models. The algorithm picks 20 candidate models at random, ranks them using LOO, and then removes the 10 worst-fitting models from the list of models under comparison. This is repeated until only 10 models remain - these are the 10 best-fitting models as ranked by LOO (under the PSIS-LOO approximation; see the `loo` package documentation and papers by Aki Vehtari and colleagues).

```{r}
if(!file.exists("data/model_selection_table.rds")){
  
  # Get the file names of the 361 models
  out_files <- list.files("/Volumes/LACIE_SHARE/brms_respiration", full.names = TRUE)
  
  # Algorithm to pick the top 10 models without running out of memory
  while(length(out_files) > 20){
    
    # Pick 20 random models that have not yet been eliminated
    sampled_files <- sample(out_files, 20)
    
    # Rank all 20 models using LOO cross-validation
    weights <- model_weights(
      readRDS(sampled_files[1]), readRDS(sampled_files[2]),
      readRDS(sampled_files[3]), readRDS(sampled_files[4]),
      readRDS(sampled_files[5]), readRDS(sampled_files[6]),
      readRDS(sampled_files[7]), readRDS(sampled_files[8]),
      readRDS(sampled_files[9]), readRDS(sampled_files[10]),
      readRDS(sampled_files[11]), readRDS(sampled_files[12]),
      readRDS(sampled_files[13]), readRDS(sampled_files[14]),
      readRDS(sampled_files[15]), readRDS(sampled_files[16]),
      readRDS(sampled_files[17]), readRDS(sampled_files[18]),
      readRDS(sampled_files[19]), readRDS(sampled_files[20]),
      weights = "loo")
    
    # Discard all but the 10 top-ranked models from the set still to be compared
    to_keep <- sampled_files[order(weights, decreasing=TRUE)[1:10]]
    to_remove <- sampled_files[!(sampled_files %in% to_keep)]
    out_files <- out_files[!(out_files %in% to_remove)]
    print(paste(length(out_files), "left to compare"))
  }
  
  top_model_files <- out_files
  saveRDS(top_model_files, "data/top_model_files.rds")
  
  # Get the weights for the top 10 models
  resp_model_weights <- model_weights(
    readRDS(top_model_files[1]), readRDS(top_model_files[2]),
    readRDS(top_model_files[3]), readRDS(top_model_files[4]),
    readRDS(top_model_files[5]), readRDS(top_model_files[6]),
    readRDS(top_model_files[7]), readRDS(top_model_files[8]),
    readRDS(top_model_files[9]), readRDS(top_model_files[10]),
    weights = "loo"
  )
  
  # Format them nicely in a table
  resp_model_weights <- round(resp_model_weights, 3) 
  names(resp_model_weights) <- out_files[as.numeric(str_extract(names(resp_model_weights), "[:digit:]+"))]
  names(resp_model_weights) <- all_formulas[as.numeric(str_extract(names(resp_model_weights), "[:digit:]+"))]
  
  ction_table <- enframe(resp_model_weights, name = "Model", value = "LOO model weight") %>%
    arrange(-`LOO model weight`) %>%
    mutate(Model = str_remove_all(Model, " \\+ \\(1 \\| LINE\\) \\+ \\(1 \\| SAMPLE\\)\\) \\+ bf\\("),
           Model = str_remove_all(Model, "bf\\("),
           Model = str_remove_all(Model, "~ VO2 \\* \\(0.7 \\+ 0.3 \\* inv_logit\\(RQ\\)\\), "),
           Model = str_remove_all(Model, " \\+ \\(1 \\| LINE\\) \\+ \\(1 \\| SAMPLE\\), nl = TRUE\\) \\+ set_rescor\\(FALSE\\)")) %>%
    mutate(split = strsplit(Model, split = " RQ"),
           `Model of VO2` = map_chr(split, ~ .x[1]),
           `Model of RQ` = map_chr(split, ~ .x[2])) %>%
    mutate(`Model of VO2` = str_remove_all(`Model of VO2`, "VO2 "),
           `Model of VO2` = str_remove_all(`Model of VO2`, "VCO2"),
           `Model of RQ` = str_replace_all(`Model of RQ`, " ~", "~")) %>%
    select(`Model of VO2`, `Model of RQ`, `LOO model weight`) 
  
  saveRDS(model_selection_table, file = "data/model_selection_table.rds")
} else {
  top_model_files <- readRDS("data/top_model_files.rds")
  model_selection_table <- readRDS("data/model_selection_table.rds")
}
```


#### Model selection table

This table shows the top ten models from the set of 361 that was compared. The models were compared using leave-one-out cross validation (LOO), which is similar to more familiar metrics like AIC, but is regarded as the current best method for comparing the fit of a set of Bayesian models (see the documentation in `brms` and `loo` packages).

```{r}
library(formattable)

model_selection_table %>%
  mutate_if(is.character, ~ str_replace_all(.x, "CYCLE", "Cycle")) %>%
  mutate_if(is.character, ~ str_replace_all(.x, "SELECTION", "Selection")) %>%
  mutate_if(is.character, ~ str_replace_all(.x, "SEX", "Sex")) %>%
  mutate(`LOO model weight` = color_bar("lightgreen")(`LOO model weight`)) %>%
  kable(escape = F, full.width = FALSE) %>% kable_styling()
```

### Inspect the parameter estimates

#### Perform Bayesian model averaging
Since there is no model that was strongly preferred to all the others, we here perform model averaging to calculate the parameter estimates for all the fixed effects that were present in at least 1 of the top 3 models. Parameters that were not present in all models were set to zero for models that lacked that parameter: this is sometimes called "full model averaging" (see e.g. ?MuMIn::model.avg), and it applies "shrinkage", meaning that parameters that are not present in all of the top models get shrunk somewhat towards zero. The models are averaged according to their "stacking weights", which is the current state-of-the-art for Bayesian model averaging (see e.g. [here](https://mc-stan.org/loo/articles/loo2-weights.html)).

```{r}
avg <- posterior_average(
  readRDS(top_model_files[1]), readRDS(top_model_files[2]), readRDS(top_model_files[3]),
  weights = "stacking", missing = 0) %>%
  select(contains("b_"), contains("sd_"))

make_model_summary_table <- function(posterior_samples){
  pvalues <- summarise_all(posterior_samples, p_direction) %>% 
    gather(key, p) %>%
    mutate(p = 1 - p) %>%
    mutate(` ` = ifelse(p < 0.05, "\\*", ""),
           ` ` = replace(` `, p > 0.05 & p < 0.1, "~"),
           ` ` = replace(` `, p < 0.01, "**"), 
           ` ` = replace(` `, p < 0.001, "***"))
  
  posterior_samples %>%
    summarise_all(~ list(posterior_summary(.x)))  %>% gather() %>% 
    mutate(Estimate = map_dbl(value, ~ .x[1]),
           Error = map_dbl(value, ~ .x[2]),
           Q2.5 = map_dbl(value, ~ .x[3]),
           Q97.5 = map_dbl(value, ~ .x[4])) %>% 
    select(-value) %>%
    left_join(pvalues, by = "key") %>%
    mutate_if(is.numeric, ~ round(.x, 3)) %>%
    mutate(p = replace(p, grepl("sd_", key), " "),
           p = replace(p, grepl("sigma_", key), " "),
           p = replace(p, grepl("Intercept_", key), " "),
           ` ` = replace(` `, grepl("sd_", key), " "),
           ` ` = replace(` `, grepl("sigma_", key), " "),
           ` ` = replace(` `, grepl("Intercept_", key), " "))
}
```

### Inspect tables of results {.tabset}
Here we present the model-averaged estimates for each of the fixed effects, as well as the results for the top model that contained our most interesting predictor, namely the M vs P selection treatment (i.e. the second-best model in the model selection table). 

#### Results from model averaging
```{r}
model_averaging_results <- avg %>%
  select(-starts_with("r_"), -starts_with("z_"), -starts_with("lp"), -starts_with("sd_")) %>% 
  make_model_summary_table() %>%
  mutate(key = str_remove_all(key, "b_"),
         split = strsplit(key, split = "_"),
         resp = map_chr(split, ~ .x[1]),
         Parameter = map_chr(split, ~ tail(.x, 1)),
         resp = replace(resp, resp == "VCO2", "RQ"),
         Parameter = replace(Parameter, Parameter == "CYCLEIII", "Cycle (III)"),
         Parameter = replace(Parameter, Parameter == "CYCLEII", "Cycle (II)"),
         Parameter = replace(Parameter, Parameter == "SEXM", "Sex (M)"),
         Parameter = replace(Parameter, Parameter == "CYCLEIII:SEXM", "Cycle (III) x Sex (M)"),
         Parameter = replace(Parameter, Parameter == "CYCLEII:SEXM", "Cycle (II) x Sex (M)"),
         Parameter = replace(Parameter, Parameter == "SELECTIONPoly:SEXM", "Treatment (P) x Sex (M)"),
         Parameter = replace(Parameter, Parameter == "SELECTIONPoly", "Treatment (P)")) %>%
  select(resp, Parameter, everything()) %>% select(-split, -key) %>%
  arrange(desc(resp))

saveRDS(model_averaging_results, "online_supp/model_averaging_results.rds")


model_averaging_results %>%
  kable() %>%
  kable_styling(full_width = FALSE)
```

#### Results from the individual top model containing selection
```{r}
top_model_with_selection <- posterior_samples(readRDS(top_model_files[2])) %>%
  select(-starts_with("r_"), -starts_with("z_"), -starts_with("lp"), 
         -starts_with("Intercept_"), -starts_with("sd_"), -starts_with("sigma_")) %>% 
  make_model_summary_table() %>%
  mutate(key = str_remove_all(key, "b_"),
         split = strsplit(key, split = "_"),
         resp = map_chr(split, ~ .x[1]),
         Parameter = map_chr(split, ~ tail(.x, 1)),
         resp = replace(resp, resp == "VCO2", "RQ"),
         Parameter = replace(Parameter, Parameter == "SELECTIONPoly", "Treatment (P)"),
         Parameter = replace(Parameter, Parameter == "CYCLEIII", "Cycle (III)"),
         Parameter = replace(Parameter, Parameter == "CYCLEII", "Cycle (II)"),
         Parameter = replace(Parameter, Parameter == "SEXM", "Sex (M)")) %>%
  select(resp, Parameter, everything()) %>% select(-split, -key)
  
saveRDS(top_model_with_selection, "online_supp/top_model_with_selection.rds")

top_model_with_selection %>%
  kable() %>%
  kable_styling(full_width = FALSE)
```

### Plot the parameter estimates {.tabset}
Again, we plot the estimates for model averaging, or the top model that contained selection treatment. We do not plot the estimates for RQ, since none of the parameter estimates clearly differed from zero.

#### Model averaged estimates
```{r}
name_converter <- tibble(
  new_name = c("O2: Male sex", "O2: P treatment", "O2: Cycle II", "O2: Cycle III",
               "O2: Male x Cycle II interaction", "O2: Male x Cycle III interaction",
               "RQ: Male sex", "RQ: Cycle II", "RQ: Cycle III"),
  old_name = c("VO2_SEXM", "VO2_SELECTIONPoly", "VO2_CYCLEII", "VO2_CYCLEIII",
               "VO2_CYCLEII:SEXM", "VO2_CYCLEIII:SEXM",
               "VCO2_RQ_SEXM", "VCO2_RQ_CYCLEII", "VCO2_RQ_CYCLEIII")
) %>% mutate(new_name = factor(new_name, rev(new_name)))

overall_SD_VO2 <- scaled_data$VO2 %>% sd()

plotter <- function(posterior_samples){
  
  posterior_samples %>% 
    as_tibble() %>%
    select(contains("b_"), -contains("Intercept")) %>%
    gather() %>% 
    mutate(key = str_remove_all(key, "b_")) %>%
    left_join(name_converter, by = c("key" = "old_name")) %>%
    mutate(variable = ifelse(grepl("O2", new_name), "O2", "RQ")) %>%
    filter(variable == "O2") %>%
    mutate(new_name = factor(str_remove(as.character(new_name), "O2: "),
                             rev(unique(str_remove(as.character(new_name), "O2: "))))) %>%
    mutate(value = value / overall_SD_VO2) %>%
    ggplot(aes(value, new_name, fill = new_name)) + 
    geom_vline(xintercept = 0, linetype = 2) + 
    geom_density_ridges(alpha = 0.7) +
    scale_fill_brewer(palette = "Spectral") +
    ylab("Model parameter") +
    xlab("Effect on O2 consumption (SD)") + 
    theme_ridges() +
    theme(legend.position = "none") +
    coord_cartesian(xlim = c(-1.4, 1.7))
}

plotter(avg)
```

#### Estimates from the individual top model containing selection
```{r}
plotter(readRDS(top_model_files[2]))
```


### Plot posterior predictive checks
Finally, we check that the values predicted by the (second-top) model resemble the real data (which they should, if the model is an adequate approximation of the true 'data-generating processes'). This is done by drawing 10 samples from the posterior of the model, and using them to produce some new data (here, for VO2). The plot looks good, because the predicted data look similar to the original data, which is a necessary condiction for reliable inference.
```{r}
pp_check(readRDS(top_model_files[2]), resp = "VO2")
```



## Fit the `brms` structural equation model (SEM)

This next section fits a more complex version of previous multivariate model, which additionally includes the "mediator variables" (for definition, see e.g. [Wikipedia](https://en.wikipedia.org/wiki/Mediation_(statistics))) body mass and activity. The mediator variables potentially vary between sexes and selection treatments (and cycle, in the case of activity, but not body size), but they also potentially affect the main response variables, VO2 and RQ. Therefore, body mass and activity potentially "mediate" the effect of treatment, sex, and cycle on respiration. Using a structural equation model, one can partition an effect (e.g. the effect of treatment on respiration) into the share that is due to mediation vs other processes. For a good introduction to causal inference using Bayesian statistics, see [this video lecture](https://www.youtube.com/watch?v=0Jc6Kgw5qc0&list=PLDcUM9US4XdNM4Edgs7weiyIguLSToZRI&index=7) and others in that series.

To limit the complexity of this already complex analysis, we forego a model selection step and simply fit the full model and analyse it. 


### Formulae in the structural equation model

The SEM contains two additional formulae than the previous model, as well as additional predictor variables. 

There is a sub-model for both of the mediator variables (activity and body mass), a model of oxygen production (VO2), and a model of CO2 production (VCO2, which is related to VO2 via the parameter RQ, the respiratory quotient, which the model also estimates). 

The formulae were chosen _a priori_, to reflect our biological intuition about the direction of causality, and the factors that might affect each response variable.

#### Activity level (one value per cycle, i.e. 3 measures on each 'sample' of individuals)

Formula: `ACTIVITY ~ SELECTION * SEX + CYCLE + (1 | LINE) + (1 | SAMPLE)`

This formula allows for effects on activity of sex and selection treatment (and their 2-way interaction), and for an effect of cycle (coded as a 3-level factor, allowing non-linear change across the 3 cycles). The random factors were added due to our repeated measures of replicate selection lines and samples (same for the following forrmulae).

#### Body mass

Formula: `BODYMASS ~ SELECTION * SEX + (1 | LINE)`

This formula allows for effects on activity of sex and selection treatment (and their 2-way interaction). Because there is only one measure of body mass for each sample of flies, we do not need to fit a sample-level random effect; also, this model is run on only a subset of the full dataset (one of the 3 cycles), since we would incur pseudo-replication if we used the full dataset. Note that this means there is less replication for body mass than for the other variables, and so the parameter estimates are less precise for this model (visible in the figures plotted later).

#### VO2

Formula: `VO2 ~ SELECTION * SEX * CYCLE + BODYMASS + ACTIVITY +`  
         `SELECTION:BODYMASS + SELECTION:ACTIVITY +` 
         `SEX:BODYMASS + SEX:ACTIVITY + (1 | LINE) + (1 | SAMPLE)`
         
This formula allows for effects on activity of sex, selection and cycle (and their 2- and 3-way interactions), and for sex- and selection treatment-specific effects of body mass and activity level.

#### VCO2 (as determined by the parameter RQ) 

Formulae (2-part model, see `vignette("brms_nonlinear")`): 

`VCO2 ~ VO2 * (0.7 + 0.3 * inv_logit(RQ))`

`RQ ~ SELECTION * SEX * CYCLE + BODYMASS + ACTIVITY +`  
`SELECTION:BODYMASS + SELECTION:ACTIVITY +` 
`SEX:BODYMASS + SEX:ACTIVITY + (1 | LINE) + (1 | SAMPLE)`

VCO2 is assumed to depend on the value of VO2 from the same measurement, multiplied by RQ, a parameter that is constrained to vary between 0.7 and 1 (based on our prior knowledge of the chemistry of respiration) through the use of the inverse logit function. In turn, RQ is assumed to depend on the same set of predictors as for VO2. 

#### Priors

To apply some mild regularisation and assist model convergence, we set a prior on all the fixed effect parameters of `normal(0, 3)`.

#### Family

All response variables are assumed to follow a normal (Gaussian) distribution, except for activity level (which follows a beta distribution); as we shall see, this turns out to be a reasonable approximation of the response variables' true distributions.

### Fit the `brms` model

```{r}
# add a subsetting variable, so that we can estimate the effects of selection and sex 
# on body size without having three redundant measures of body size (one per cycle). 
# See ?brmsformula, section beginning "For multivariate models, subset may be used..."
scaled_data <- scaled_data %>%
  mutate(body_subset = CYCLE == "I")    

if(!file.exists("output/brms_SEM.rds")){
  
  # Set up formula for the SEM:
  brms_formula <- 
    
    bf(VO2 ~ SELECTION * SEX * CYCLE +  # VO2 sub-model
         BODYMASS + ACTIVITY +  
         SELECTION:BODYMASS + SELECTION:ACTIVITY + 
         SEX:BODYMASS + SEX:ACTIVITY + 
         (1 | LINE) + (1 | SAMPLE)) +
    
    bf(VCO2 ~ VO2 * (0.7 + 0.3 * inv_logit(RQ)),   # VCO2 and RQ sub-models
       RQ ~ SELECTION * SEX * CYCLE + 
         BODYMASS + ACTIVITY + 
         SELECTION:BODYMASS + SELECTION:ACTIVITY + 
         SEX:BODYMASS + SEX:ACTIVITY + 
         (1 | LINE) + (1 | SAMPLE),
       nl = TRUE) +
    
    bf(BODYMASS | subset(body_subset) ~ SELECTION * SEX + # body mass sub-model
         (1 | LINE)) +
    
    bf(ACTIVITY ~ SELECTION * SEX * CYCLE +   # activity sub-model
         (1 | LINE) + (1 | SAMPLE)) +   # , family = "beta"
    
    set_rescor(FALSE)
  
  # Run the SEM:
  brms_SEM <- brm(
    brms_formula,  
    data = scaled_data,
    iter = 10000, chains = 4, cores = 1,
    prior = prior(normal(0, 1), class = "b"),
    control = list(max_treedepth = 20, adapt_delta = 0.999)
  )
  
  saveRDS(brms_SEM, file = "output/brms_SEM.rds")
  
} else {
  brms_SEM <- readRDS("output/brms_SEM.rds")
}
```


### Inspect the model output
Here is the complete output of `summary()` called on the SEM. Note that the model has converged (Rhat = 1), and that no parameters are under-sampled (shown by the ESS columns). Several parameters also differ significantly from zero (shown by their 95% credible intervals not overlapping zero). Note that the response variables are not all in the same units, so the magnitudes of the parameter estimates ("Estimate" column) are not directly comparable between the response variables.
```{r output_max_height = "300px"}
summary(brms_SEM)
```

### Make a neat table of the fixed effects
```{r}
pvalues <- as.data.frame(p_direction(brms_SEM)) %>% 
  filter(!grepl("[.]1", Parameter)) %>%
  mutate(Parameter = str_remove_all(Parameter, "b_"),
         Parameter = str_replace_all(Parameter, "[.]", ":"),
         p = 1 - pd) %>%
  select(Parameter, p) %>% distinct()


SEM_fixed_effects <- fixef(brms_SEM) %>% 
  as.data.frame() %>%
  rownames_to_column("Parameter") %>%
  left_join(pvalues, by = "Parameter") %>%
  mutate(` ` = ifelse(p < 0.05, "\\*", ""),
         ` ` = replace(` `, p > 0.05 & p < 0.1, "~"),
         ` ` = replace(` `, p < 0.01, "**"), 
         ` ` = replace(` `, p < 0.001, "***")) %>%
  mutate(Response = map_chr(strsplit(Parameter, split = "_"), ~ .x[1]),
         Response = str_replace_all(Response, "BODYMASS", "Body mass"),
         Response = str_replace_all(Response, "ACTIVITY", "Activity"),
         Response = str_replace_all(Response, "VCO2", "RQ"),
         Parameter = str_replace_all(Parameter, "BODYMASS", "Body mass"),
         Parameter = str_replace_all(Parameter, "ACTIVITY", "Activity"),
         Parameter = str_remove_all(Parameter, ".+_"),
         Parameter = str_replace_all(Parameter, "SELECTIONPoly", "Polyandry"),
         Parameter = str_replace_all(Parameter, "CYCLEIII", "Cycle III"),
         Parameter = str_replace_all(Parameter, "CYCLEII", "Cycle II"),
         Parameter = str_replace_all(Parameter, "SEXM", "Male"),
         Parameter = str_replace_all(Parameter, ":", " x ")) %>%
  select(Response, Parameter, everything()) %>%
  mutate(Response = factor(Response, 
                           c("Activity", "Body mass", "VO2", "RQ"))) %>%
  arrange(Response) %>% 
  select(-Response) 

saveRDS(SEM_fixed_effects, "online_supp/SEM_fixed_effects.rds")

SEM_fixed_effects %>%
  kable(digits = 3) %>% 
  kable_styling(full_width = FALSE) %>%
  group_rows("Activity level", 1, 12) %>%
  group_rows("Body mass", 13, 16) %>%
  group_rows("VO2", 17, 34) %>%
  group_rows("Respiratory quotient (RQ)", 35, 52)
```


### Plot posterior predictive checks
Again, the fit looks ok.
```{r}
pp_check(brms_SEM, resp = "VO2")
```

### Extract the posterior estimates of the means
These are used for plotting the range of means that is supported by the data, given our priors. The posterior estimates show the mean of each group, accounting for all the random effects (i.e. the design of the experiment), the covariance structure of the response variables, etc. 

We will also use these posteriors for hypothesis testing, e.g. to see if the mean body size of the polyandry flies differs from that of monogamy flies, by subtracting one posterior from the other to get the posterior estimate of the _difference_ in means. If most (e.g. >95%) of this posterior difference lies on one side of zero, the two means may be considered 'significantly different' as conventionally defined. The magnitude of the difference in means is also an intuitive measure of effect size, and the posterior gives a sense of how precisely we have estimated effect size.

```{r posterior_predictions}
new <- scaled_data %>%
  select(SELECTION, SEX, CYCLE) %>%
  distinct() %>%
  mutate(body_subset = TRUE)

# Get the posterior estimate of body weight and activity,
# for the 4 combinations of sex and monogamy/polandry treatment
bodymass <- brms_SEM %>%
  fitted(newdata = new, re_formula = NA,
         resp = "BODYMASS", summary = FALSE)
activity <- brms_SEM %>%
  fitted(newdata = new, re_formula = NA,
         resp = "ACTIVITY", summary = FALSE)

new <- left_join(
  data.frame(new, t(bodymass)) %>%
    gather(draw, BODYMASS, starts_with("X")) %>% as_tibble(),
  data.frame(new, t(activity)) %>%
    gather(draw, ACTIVITY, starts_with("X")) %>% as_tibble(),
  by = c("SELECTION", "SEX", "CYCLE", "body_subset", "draw")) %>%
  mutate(draw = as.numeric(str_remove_all(draw, "X")))

new <- bind_rows(
  new %>% mutate(mediators_blocked = "Neither"),
  new %>% mutate(mediators_blocked = "Activity",
                 ACTIVITY = mean(scaled_data$ACTIVITY)),
  new %>% mutate(mediators_blocked = "Body mass",
                 BODYMASS = mean(scaled_data$BODYMASS))
  ) %>%
  mutate(VO2 = as.numeric(NA),
         RQ = as.numeric(NA)) %>% arrange(draw)


if(length(list.files("output/temp_files", full.names = TRUE)) < 20000){
  lapply(1:max(new$draw), function(i){
    print(i)
    focal <- new[new$draw == i, ]
    focal_draw <- focal$draw[1]
    focal$VO2 <- fitted(brms_SEM, re_formula = NA, resp = "VO2",
                        newdata = focal, subset = focal_draw)[,1]
    focal$RQ <- fitted(brms_SEM, re_formula = NA, resp = "VCO2", nlpar = "RQ",
                       newdata = focal, subset = focal_draw)[,1]
    focal %>% saveRDS(glue("output/temp_files/preds_{i}.rds"))
    rm(focal)
  })
}

posterior_predictions <- list.files("output/temp_files", full.names = TRUE) %>% map_df(readRDS)
new_both_blocked <-  (new[1:12, ]) %>% mutate(mediators_blocked = "Both",
                           BODYMASS = 0,
                           ACTIVITY = 0) %>%
  mutate(key = paste("V", 1:n(), sep = "")) %>% select(-RQ, -draw)

posterior_predictions <- posterior_predictions %>%
  bind_rows(
    left_join(
      fitted(brms_SEM, re_formula = NA, resp = "VO2",
             newdata = new_both_blocked, summary = FALSE) %>%
        as.data.frame() %>% mutate(draw = 1:n()) %>% gather(key, VO2_pred, -draw) %>% 
        left_join(new_both_blocked, by = "key"),
      fitted(brms_SEM, re_formula = NA, resp = "VCO2", nlpar = "RQ",
             newdata = new_both_blocked, summary = FALSE) %>%
        as.data.frame() %>% mutate(draw = 1:n()) %>% gather(key, RQ, -draw) %>% 
        left_join(new_both_blocked, by = "key"), 
      by = c("draw", "key", "SELECTION", "SEX", "CYCLE", 
             "body_subset", "BODYMASS", "ACTIVITY", "mediators_blocked", "VO2")
    ) %>% as_tibble() %>% 
      select(-VO2) %>% rename(VO2 = VO2_pred) %>%
      select(!! names(posterior_predictions))
  ) %>% mutate(RQ = 0.7 + 0.3 * inv_logit(RQ))
```


## Effect of selection treatment on mediator variables

Here, we see that triads of flies from the M and P selection treatments differ strongly in activity levels, and (for females) in body mass. Thus, in subsequent analyses, we attempt to partition out the effect of selection on respiration that is due to the difference in body size, activity, or other unmeasured mediator variables (e.g. physiological differences).

```{r}
parse_mediators <- function(x){
  var <- x
  x <- get(x)
  ndraws <- nrow(x)
  colnames(x) <- apply(new[1:12, ], 1, paste0, collapse="~")
  gather(as_tibble(x)) %>%
    mutate(draw = rep(1:ndraws, 12),
           split = strsplit(key, split = "~"),
           SELECTION = map_chr(split, ~.x[1]),
           CYCLE = map_chr(split, ~.x[3]),
           SEX = map_chr(split, ~.x[2])) %>%
    select(draw, SEX, SELECTION, CYCLE, value) %>%
    mutate(mediator = var)
}

parsed_bodymass <- parse_mediators("bodymass") %>%
  filter(CYCLE == "I")

parsed_activity <- parse_mediators("activity")

pd <- position_dodge(0.4)
overall_SD_VO2 <- scaled_data$VO2 %>% sd()
overall_mean_VO2 <- scaled_data$VO2 %>% mean()
overall_SD_RQ <- scaled_data$RQ %>% sd()
overall_mean_RQ <- scaled_data$RQ %>% mean()



posterior_means_plot <- posterior_predictions %>%
  select(draw, SELECTION, SEX, CYCLE, VO2, RQ) %>%
  mutate(VO2 = (VO2 - overall_mean_VO2) / overall_SD_VO2,
         RQ = (RQ - overall_mean_RQ) / overall_SD_RQ) %>%
  left_join((parsed_activity) %>% select(-mediator) %>% rename(Activity = value), 
            by = c("draw", "SELECTION", "SEX", "CYCLE")) %>%
  left_join((parsed_bodymass) %>% select(-mediator, -CYCLE) %>% 
              rename(`Body mass` = value), 
            by = c("draw", "SELECTION", "SEX")) %>%
  filter(!is.na(Activity)) %>%
  gather(resp, value, VO2, RQ, Activity, `Body mass`) %>%
  filter(!(resp == "Body mass" & CYCLE %in% c("II", "III"))) %>%
  mutate(CYCLE = replace(CYCLE, resp == "Body mass", "All")) %>%
  mutate(SEX = factor(ifelse(SEX == "M", "Males", "Females"), c("Males", "Females"))) %>%
  mutate(resp = replace(resp, resp == "VO2", "O2")) %>%
  mutate(resp = factor(resp, c("O2", "RQ", "Activity", "Body mass"))) %>%
  mutate(SELECTION = ifelse(SELECTION == "Mono", "Monogamy", "Polyandry")) %>%
  ggplot(aes(CYCLE, value, colour = SELECTION)) + 
  geom_hline(yintercept = 0, linetype = 2) + 
  stat_pointinterval(position = pd, fill = NA, .width = c(0.5, 0.95), alpha = 0.7) + 
  scale_colour_brewer(palette = "Set1", direction = -1, name = "") +
  theme_bw() + 
  theme(legend.position = "top", panel.grid.major.x = element_blank()) + 
  facet_grid(SEX ~ resp, scales = "free") +
  xlab("Cycle") + 
  ylab("Posterior estimate of the mean")

posterior_means_plot %>% ggsave(filename = "output/posterior_means_plot.pdf", width = 6, height = 4.1)
posterior_means_plot
```

**Figure 3:** LEGEND HERE




## Effect of selection treatment on respiration

### Plot the effect size for M/P treatment on O2 consumption

The plot show the model's best estimates of the effect size of the M/P treatment on VO2, defined as the posterior estimate of difference in mean O2 consumption, divided by the standard deviation in O2 consumption (i.e. Cohen's $d$). Positive effect size indicates higher O2 consumption in the polyandry treatment compared to the monogamy treatment.

Effect size was calculated while statistically controlling for one, both, or neither of the two mediator variables (termed "blocking" the mediator variables). Note that the effect size is smaller when activity is controlled for, while controlling for body size had no effect on effect size. Additionally, controlling for activity caused the effect size of the M/P treatment to become statistically indistinguishable from zero. The results therefore indicate that activity mediates most, perhaps all, of the effect of treatment on O2 consumption.


```{r fig.height=4.7, fig.width=8}
mediation_figure_VO2 <- posterior_predictions %>%
  mutate(mediators_blocked = replace(mediators_blocked, mediators_blocked == "Body mass", "Body\nmass")) %>%
  mutate(mediators_blocked = factor(mediators_blocked, c("Neither", "Body\nmass", "Activity", "Both"))) %>%
  mutate(SEX = factor(ifelse(SEX=="M", "Males", "Females"), c("Males", "Females"))) %>%
  mutate(CYCLE = paste("Cycle", CYCLE)) %>%
  group_by(draw, SEX, CYCLE, mediators_blocked) %>%
  summarise(VO2_effect = (VO2[SELECTION == "Poly"] - VO2[SELECTION == "Mono"]) / overall_SD_VO2) %>%
  ungroup() %>% 
  ggplot(aes(x = mediators_blocked, 
             y = VO2_effect)) + 
  geom_hline(yintercept = 0, linetype = 2) + 
  stat_pointinterval(point_size = 4) + 
  facet_grid(SEX ~ CYCLE) +
 # coord_cartesian(ylim = c(-1.2, 2.4)) +
  ylab("Effect size of polyandry treatment\non O2 consumption (Cohen's d)") + 
  xlab("Mediator variables that were controlled for")  +
  theme_bw() +
  theme(legend.position = "none")

mediation_figure_VO2 %>% ggsave(filename = "output/mediation_figure_VO2.pdf", height=4.7, width=8)

mediation_figure_VO2
```

**Figure S2**: LEGEND HERE

### Plot the effect size for M/P treatment on RQ

Equivalent plot, for RQ. Positive effect size indicates higher RQ (i.e. more carbohydrate metabolism and/or less lipid metabolism) in the polyandry treatment compared to the monogamy treatment.

Note that there is little evidence for an effect of treatment on RQ, except perhaps in Cycle III in females. However, we were not able to measure the effect of treatment on RQ with sufficient precision to rule out the existence of a large effect.

```{r fig.height=4.7, fig.width=8}

mediation_figure_RQ <- posterior_predictions %>%
  mutate(mediators_blocked = factor(mediators_blocked, c("Neither", "Body mass", "Activity", "Both"))) %>%
  mutate(SEX = factor(ifelse(SEX=="M", "Males", "Females"), c("Males", "Females"))) %>%
  mutate(CYCLE = paste("Cycle", CYCLE)) %>%
  group_by(draw, SEX, CYCLE, mediators_blocked) %>%
  summarise(RQ_effect = (RQ[SELECTION == "Poly"] - RQ[SELECTION == "Mono"]) / overall_SD_RQ) %>%
  ungroup() %>% 
  ggplot(aes(x = mediators_blocked, 
             y = RQ_effect)) + 
  geom_hline(yintercept = 0, linetype = 2) + 
  stat_pointinterval(point_size = 4) + 
  facet_grid(SEX ~ CYCLE) +
  ylab("Effect size of polyandry treatment\non RQ (Cohen's d)") + 
  xlab("Mediator variables that were controlled for")  +
  theme_bw() +
  theme(legend.position = "none")

mediation_figure_RQ %>% ggsave(filename = "output/mediation_figure_RQ.pdf", height=4.7, width=8)

mediation_figure_RQ
```

**Figure S3**: LEGEND HERE

<!-- ## Table of posterior means {.tabset} -->

<!-- These tables show the mean values of VO2 and RQ in each treatment/cycle/sex combination. -->

<!-- ```{r} -->
<!-- tableS1_S2 <- posterior_predictions %>% -->
<!--   gather(resp, value, VO2, RQ) %>% -->
<!--   group_by(resp, mediators_blocked, CYCLE, SEX, SELECTION) %>% -->
<!--   summarise(x = list(posterior_summary(value))) %>% -->
<!--   mutate(Estimate = map_dbl(x, ~ .x[1]), -->
<!--          Error = map_dbl(x, ~ .x[2]), -->
<!--          Lower95CI = map_dbl(x, ~ .x[3]), -->
<!--          Upper95CI = map_dbl(x, ~ .x[4])) %>% -->
<!--   select(-x) %>% ungroup() -->

<!-- tableS1 <- tableS1_S2 %>% -->
<!--   filter(resp == "VO2") %>% -->
<!--   rename(`Mean VO2` = Estimate) %>% -->
<!--   select(-resp) -->

<!-- tableS2 <- tableS1_S2 %>% -->
<!--   filter(resp == "RQ") %>% -->
<!--   rename(`Mean RQ` = Estimate) %>% -->
<!--   select(-resp) -->
<!-- ``` -->

<!-- ### VO2 -->
<!-- ```{r} -->
<!-- tableS1 %>% kable(digits=3) %>% kable_styling() -->
<!-- ``` -->

<!-- ### RQ -->
<!-- ```{r} -->
<!-- tableS2 %>% kable(digits=3) %>% kable_styling() -->
<!-- ``` -->


<!-- ## Tables of posterior differences between selection treatments -->

<!-- The table tests for differences between the M and P treatments in VO2 and RQ. It was calculated as the difference in mean VO2 or RQ between M and P, either alone, or including one or both of the two mediator variables (body size and activity level). The comparison was made separately in each sex/cycle combination. The biggest effect is on males in cycle III: the M males are less active, and therefore they respire less -- there was no evidence for a treatment effect unless the effect of selection on activity level was considered. There were no treatment effects on RQ. -->

<!-- ```{r make_posterior_diff_table} -->
<!-- my_summary <- function(posterior) { -->
<!--   p <- (100 - as.numeric(p_direction(posterior))) / 100 -->
<!--   posterior_summary(posterior) %>% -->
<!--     as.data.frame() %>% -->
<!--     mutate(p = p) %>% -->
<!--     mutate(` ` = ifelse(p < 0.05, "\\*", ""), -->
<!--            ` ` = replace(` `, p > 0.05 & p < 0.1, "~"), -->
<!--            ` ` = replace(` `, p < 0.01, "**"), -->
<!--            ` ` = replace(` `, p < 0.001, "***")) -->
<!-- } -->

<!-- make_posterior_diff_table <- function(posterior_predictions){ -->

<!--   posterior_differences <- posterior_predictions %>% -->
<!--     group_by(resp, path, sex, cycle) %>% -->
<!--     summarise(x = list(my_summary( -->
<!--       value[selection=="Mono"] - -->
<!--         value[selection=="Poly"]))) -->

<!--   bind_cols( -->
<!--     posterior_differences[,-5], -->
<!--     do.call("rbind", posterior_differences %>% pull(5)))  %>% -->
<!--     arrange(desc(resp)) -->
<!-- } -->

<!-- posterior_differences <- posterior_predictions %>% -->
<!--   make_posterior_diff_table() -->

<!-- posterior_differences %>% -->
<!--   kable(digits=3) %>% -->
<!--   kable_styling() -->
<!-- ``` -->









<!-- # FINISH THIS - OLD VERSION BELOW -->
<!-- # posterior_predictions <- new %>% -->
<!-- #   mutate(chunk = rep(1:(nrow(new) / 1000), each = 1000)) %>% # 720 chunks -->
<!-- #   split(.$chunk) %>% -->
<!-- #   map_df(~ { -->
<!-- #     focal_dat <- .x -->
<!-- #     print(focal_dat$chunk[1]) -->
<!-- #     data.frame(.x, fit = fitted(brms_SEM, re_formula = NA, resp = "VO2", newdata = focal_dat)) -->
<!-- #   }) %>% select(-chunk) %>% -->
<!-- #   rename(VO2 = fit.Estimate) %>% -->
<!-- #   select(-starts_with("fit")) %>% -->
<!-- #   as_tibble() -->




<!-- if(!file.exists("data/posterior_predictions.rds")){ -->

<!--   # Calculate the posterior VO2 and RQ for the levels of 'new', either by assuming bodysize and acitivity are at their global means, or by using the means we have estimated for each combination of selection, sex, and cycle -->
<!--   get_post_response <- function(body, act){ -->

<!--     n_combos <- nrow(new) -->
<!--     if(!body) bodyweight <- matrix(0, ncol = n_combos, nrow = 1) -->
<!--     if(!act)  activity <- matrix(0, ncol = n_combos, nrow = 1) -->

<!--     get_diagonal <- function(mat){ -->
<!--       if(ncol(mat) == nrow(mat)) return(diag(mat)) -->
<!--       mat -->
<!--     } -->

<!--     VO2_posterior <- map( -->
<!--       1:n_combos, -->
<!--       ~ brms_SEM %>% -->
<!--         fitted(data.frame( -->
<!--           SELECTION = new$SELECTION[.x], -->
<!--           SEX = new$SEX[.x], -->
<!--           CYCLE = new$CYCLE[.x], -->
<!--           BODYMASS = bodymass[, .x], -->
<!--           ACTIVITY = activity[, .x]), -->
<!--           re_formula = NA, resp = "VO2", -->
<!--           summary = FALSE) %>% -->
<!--         get_diagonal()) %>% -->
<!--       do.call("cbind", .) -->

<!--     RQ_posterior <- map( -->
<!--       1:n_combos, -->
<!--       ~ brms_SEM %>% -->
<!--         fitted(data.frame( -->
<!--           SELECTION = new$SELECTION[.x], -->
<!--           SEX = new$SEX[.x], -->
<!--           BODYMASS = bodymass[, .x], -->
<!--           ACTIVITY = activity[, .x], -->
<!--           CYCLE = new$CYCLE[.x], -->
<!--           VO2 = VO2_posterior[, .x]), -->
<!--           re_formula = NA, resp = "VCO2", -->
<!--           nlpar = "RQ", summary = FALSE) %>% -->
<!--         get_diagonal()) %>% -->
<!--       do.call("cbind", .) -->

<!--     n_draws <- nrow(VO2_posterior) -->

<!--     posterior <- tibble( -->
<!--       value = c(VO2_posterior), -->
<!--       resp = "VO2", -->
<!--       selection = rep(new$SELECTION, each = n_draws), -->
<!--       sex = rep(new$SEX, each = n_draws), -->
<!--       cycle = rep(new$CYCLE, each = n_draws) -->
<!--     ) %>% bind_rows( -->
<!--       tibble( -->
<!--         value = c(RQ_posterior), -->
<!--         resp = "RQ", -->
<!--         selection = rep(new$SELECTION, each = n_draws), -->
<!--         sex = rep(new$SEX, each = n_draws), -->
<!--         cycle = rep(new$CYCLE, each = n_draws) -->
<!--       ) -->
<!--     ) %>% mutate( -->
<!--       value = ifelse(resp == "RQ", -->
<!--                      0.7 + 0.3 * inv_logit(value), -->
<!--                      value)) -->
<!--   } -->

<!--   posterior_predictions <- list( -->
<!--     direct_path = get_post_response(body = F, act = F), -->
<!--     direct_path_plus_bodyweight = get_post_response(body = T, act = F), -->
<!--     direct_path_plus_activity = get_post_response(body = F, act = T), -->
<!--     all_paths = get_post_response(body = T, act = T)) -->

<!--   posterior_predictions <- lapply( -->
<!--     names(posterior_predictions), function(i) { -->
<!--       posterior_predictions[[i]] %>% mutate(path = i) -->
<!--     }) %>% bind_rows() %>% -->
<!--     mutate(path = factor(path, unique(path))) -->

<!--   posterior_predictions <- posterior_predictions %>% -->
<!--     mutate(sex = ifelse(sex == "M", "Male", "Female"), -->
<!--            sex = factor(sex, c("Male", "Female")), -->
<!--            path = replace(as.character(path), -->
<!--                           path == "direct_path", -->
<!--                           "1. Direct effect"), -->
<!--            path = replace(path, -->
<!--                           path == "direct_path_plus_bodyweight", -->
<!--                           "2. Direct + body mass"), -->
<!--            path = replace(path, -->
<!--                           path == "direct_path_plus_activity", -->
<!--                           "3. Direct + activity level"), -->
<!--            path = replace(path, -->
<!--                           path == "all_paths", -->
<!--                           "4. Direct + both mediators")) -->

<!--   posterior_predictions %>% -->
<!--     saveRDS("data/posterior_predictions.rds") -->
<!-- } else { -->
<!--   posterior_predictions <- -->
<!--     readRDS("data/posterior_predictions.rds") -->
<!-- } -->
<!-- ``` -->
